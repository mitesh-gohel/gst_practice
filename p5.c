/* Basic tutorial -5 : GUI toolkit integration */

#include<gtk/gtk.h>
#include<gst/gst.h>
#include<gdk/gdk.h>


typedef struct _CustomData
{
	GstElement *playbin; /* one and only elment, it will work as pipeline */
	
	GtkWidget *sink_widget; /* Widget, where video will be displayed */
	GtkWidget *slider;  /* Slider widget to keepm track of current position of video*/
	GtkWidget *streams_list; /*widget to display stream related info */
	gulong slider_update_signal_id; /*Signal id of silder update signal */

	GstState state; 	 /* Current state of pipeline */
	gint64 duration; 	/* Duration of stream */
}CustomData;

/*This is called when play button is clicked */
static void play_cb(GtkButton *button, CustomData *data)
{
	gst_element_set_state(data->playbin, GST_STATE_PLAYING);
}

/* This is callled when pause button is clicked */
static void pause_cb(GtkButton *button, CustomData *data)
{
	gst_element_set_state(data->playbin, GST_STATE_PAUSED);
}

/*This is called when stop button is clicked */
static void stop_cb(GtkButton *button, CustomData *data)
{
	gst_element_set_state(data->playbin, GST_STATE_READY);
}

/*This is called when the main window is closed */
static void delete_event_cb(GtkWidget *widget, GdkEvent *event, CustomData *data)
{
	stop_cb(NULL, data);
	gtk_main_quit();
}

/*This is called when slider position is changed */
static void slider_cb(GtkRange *range, CustomData *data)
{
	gdouble value = gtk_range_get_value(GTK_RANGE(data->slider));
	gst_element_seek_simple(data->playbin, GST_FORMAT_TIME, GST_SEEK_FLAG_FLUSH | GST_SEEK_FLAG_KEY_UNIT,
				(gint64)(value * GST_SECOND));
}


/*This will create all required widget and register the callbacks*/
static void create_ui(CustomData *data)
{
	GtkWidget *main_window; /*Uppr=ermost window containing other windows*/
	GtkWidget *main_box;	/*VBox to hold main_hbox and controls*/
	GtkWidget *main_hbox;	/*HBox to hold video sink and stream info text widget*/
	GtkWidget *controls;	/*To hold buttos and slider*/
	GtkWidget *play_button, *pause_button, *stop_button; /*buttons*/
	
	main_window = gtk_window_new(GTK_WINDOW_TOPLEVEL);
	g_signal_connect(G_OBJECT(main_window), "delete-event", G_CALLBACK(delete_event_cb), data);

	play_button = gtk_button_new_from_icon_name("media-playback-start", GTK_ICON_SIZE_SMALL_TOOLBAR);
	g_signal_connect(G_OBJECT(play_button), "clicked", G_CALLBACK(play_cb), data);

	pause_button = gtk_button_new_from_icon_name("media-playback-pause", GTK_ICON_SIZE_SMALL_TOOLBAR);
	g_signal_connect(G_OBJECT(pause_button), "clicked", G_CALLBACK(pause_cb), data);

	stop_button = gtk_button_new_from_icon_name("media-playback-stop", GTK_ICON_SIZE_SMALL_TOOLBAR);
	g_signal_connect(G_OBJECT(stop_button), "clicked", G_CALLBACK(stop_cb), data);

	data->slider = gtk_scale_new_with_range(GTK_ORIENTATION_HORIZONTAL, 0, 100, 1);
	gtk_scale_set_draw_value(GTK_SCALE(data->slider), 0);
	data->slider_update_signal_id = g_signal_connect(G_OBJECT(data->slider), "value-changed", G_CALLBACK(slider_cb), data);

	data->streams_list = gtk_text_view_new();
	gtk_text_view_set_editable(GTK_TEXT_VIEW(data->streams_list), FALSE);

	controls = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0);
	gtk_box_pack_start(GTK_BOX(controls), play_button, FALSE, FALSE, 2);
	gtk_box_pack_start(GTK_BOX(controls), pause_button, FALSE, FALSE, 2);
	gtk_box_pack_start(GTK_BOX(controls), stop_button, FALSE, FALSE, 2);
	gtk_box_pack_start(GTK_BOX(controls), data->slider, TRUE, TRUE, 2);

	main_hbox = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0);
	gtk_box_pack_start(GTK_BOX(main_hbox), data->sink_widget, TRUE, TRUE, 0);
	gtk_box_pack_start(GTK_BOX(main_hbox), data->streams_list, FALSE, FALSE, 2);

	main_box = gtk_box_new(GTK_ORIENTATION_VERTICAL, 0);
	gtk_box_pack_start(GTK_BOX(main_box), main_hbox, TRUE, TRUE, 0);
	gtk_box_pack_start(GTK_BOX(main_box), controls, FALSE, FALSE, 0);
	gtk_container_add(GTK_CONTAINER(main_window), main_box);
	gtk_window_set_default_size(GTK_WINDOW(main_window), 640, 480);

	gtk_widget_show_all(main_window);
}


/*This funcation is called when new meta data is available in stream*/
static void tags_cb(GstElement *playbin, gint stream, CustomData *data)
{
	gst_element_post_message(playbin,
		gst_message_new_application(GST_OBJECT(playbin) ,
			gst_structure_new_empty("tags-changed")));
}


/*This is called wnenn error message appears in bus*/
static void error_cb(GstBus *bus, GstMessage *msg, CustomData *data)
{
	GError *err;
	gchar *debug_info;
	
	g_printerr("Error generated by %s is : %s\n", GST_OBJECT_NAME(msg->src), err->message);
	g_printerr("Debug info : %s\n", debug_info ? debug_info : "None");
	g_clear_error(&err);
	g_free(debug_info);
	
	gst_element_set_state(data->playbin, GST_STATE_READY); /*Set pipeline in Reday state, which will stop playback*/
}


static void eos_cb(GstBus *bus, GstMessage *msg, CustomData *data)
{
	g_print("End of stream\n");
	gst_element_set_state(data->playbin, GST_STATE_READY);
}	


static gboolean refresh_ui(CustomData *data)
{
	gint64 current = -1;
	
	/* If we are not in PAUSED or PLAYING state, Do not update anything */
	if(data->state < GST_STATE_PAUSED)
		return TRUE;

	if(! GST_CLOCK_TIME_IS_VALID (data->duration))
	{
		if(!gst_element_query_duration(data->playbin, GST_FORMAT_TIME, &data->duration))
		{
			g_printerr("Unable to find duration of stream\n");
		}
		else
		{
			/* set the range of slider to clip duration in seconds */
			gtk_range_set_range(GTK_RANGE(data->slider), 0, (gdouble)data->duration / GST_SECOND);
		}	
	}

	if(gst_element_query_position(data->playbin, GST_FORMAT_TIME, &current))
	{
		g_signal_handler_block(data->slider, data->slider_update_signal_id);   /* Block "value-changed" signal , so slider functionn is not called */
		gtk_range_set_value(GTK_RANGE(data->slider), (gdouble)current / GST_SECOND);
		g_signal_handler_unblock(data->slider, data->slider_update_signal_id);
	}

	return TRUE;
}

static void state_changed_cb(GstBus *bus, GstMessage *msg, CustomData *data)
{
	GstState old_state, new_state, pending_state;
	gst_message_parse_state_changed(msg, &old_state, &new_state, &pending_state);
	if(GST_MESSAGE_SRC(msg) == GST_OBJECT(data->playbin))
	{
		g_print("state is changed from %s to %s\n", gst_element_state_get_name(old_state), gst_element_state_get_name(new_state));
		data->state = new_state;
		if(old_state == GST_STATE_READY  &&  new_state == GST_STATE_PAUSED)
		{
			/* For extra resposibilites, we refresh GUI as soon as we reach PAUSED state */
			refresh_ui(data);
		}
	}
}


/* Extract metadata from stream and write it to the text widget */
static void analyze_stream(CustomData *data)
{
	gint i;
	GstTagList *tags;
	gchar *str, *total_str;
	guint rate;
	gint n_video, n_audio, n_text;
	GtkTextBuffer *text;
	
	/*Clean current content of text widget*/
	text = gtk_text_view_get_buffer(GTK_TEXT_VIEW(data->streams_list));
	gtk_text_buffer_set_text(text, "", -1);

	g_object_get(data->playbin, "n-video", &n_video, NULL);
	g_object_get(data->playbin, "n-audio", &n_audio, NULL);
	g_object_get(data->playbin, "n-text", &n_text, NULL); 

	for(i=0; i < n_video; ++i)
	{
		tags = NULL;
		/* Retrive stream's video tags */
		g_signal_emit_by_name(data->playbin, "get-video-tags", i, &tags);
		if(tags)
		{
			total_str = g_strdup_printf("Video stream %d :\n", i);
			gtk_text_buffer_insert_at_cursor(text, total_str, -1);
			g_free(total_str);
			gst_tag_list_get_string(tags, GST_TAG_VIDEO_CODEC, &str);
			total_str = g_strdup_printf(" codec : %s\n", str ? str : "unknown");
			gtk_text_buffer_insert_at_cursor(text, total_str, -1);
			g_free(total_str);
			g_free(str);
			gst_tag_list_free(tags);
		}
	}

	for(i=0; i<n_audio; ++i)
	{
		tags = NULL;
		g_signal_emit_by_name(data->playbin, "get-audio-tags", i, &tags);
		if(tags)
		{
			total_str = g_strdup_printf("\nAudio stream %d :\n", i);
			gtk_text_buffer_insert_at_cursor(text, total_str, -1);
			g_free(total_str);
			if(gst_tag_list_get_string(tags, GST_TAG_AUDIO_CODEC, &str))
			{
				total_str = g_strdup_printf(" codec %s\n", str);
				gtk_text_buffer_insert_at_cursor(text, total_str, -1);
				g_free(total_str);
				g_free(str);
			}

			if(gst_tag_list_get_string(tags, GST_TAG_LANGUAGE_CODE, &str))
			{
				total_str = g_strdup_printf(" language : %s\n", str);
				gtk_text_buffer_insert_at_cursor(text, total_str, -1);
				g_free(total_str);
				g_free(str);
			}

			if(gst_tag_list_get_uint(tags, GST_TAG_BITRATE, &rate))
			{
				total_str = g_strdup_printf(" bitrate : %d\n", rate);
				gtk_text_buffer_insert_at_cursor(text, total_str, -1);
				g_free(total_str);
			}
			gst_tag_list_free(tags);
		}
	}

	for(i=0; i<n_text; ++i)
	{
		tags = NULL;
		/* Retrive stream's subtitle tags */
		g_signal_emit_by_name(data->playbin, "get-text-tags", i, &tags);
		if(tags)
		{
			total_str = g_strdup_printf("\nSubtitle stream %d :\n", i);
			gtk_text_buffer_insert_at_cursor(text, total_str, -1);
			if(gst_tag_list_get_string(tags, GST_TAG_LANGUAGE_CODE, &str))
			{
				total_str = g_strdup_printf(" language : %s\n", str);
				gtk_text_buffer_insert_at_cursor(text, total_str, -1);
				g_free(total_str);
				g_free(str);
			}
			gst_tag_list_free(tags);
		}
	}
}


/* This is called when application type of message is posted on the bus */
static void application_cb(GstBus *bus, GstMessage *msg, CustomData *data)
{
	/* If message is "tag-changed" then update stream info in GUI*/
	if(g_strcmp0(gst_structure_get_name(gst_message_get_structure(msg)), "tags-changed") == 0)
	{
		analyze_stream(data);
	}
}


int main(int argc, char **argv)
{
	CustomData data;
	GstBus *bus;
	GstStateChangeReturn ret;
	GstElement *videosink, *gtkglsink;

	g_print("PID = %d\n", getpid());
	
	/*initialize gtk */
	gtk_init(&argc, &argv);

	gst_init(&argc, &argv);

	memset(&data, 0, sizeof(data));
	data.duration = GST_CLOCK_TIME_NONE;

	data.playbin = gst_element_factory_make("playbin", "playbin");
	videosink = gst_element_factory_make("glsinkbin", "glsinkbin");
	gtkglsink =  gst_element_factory_make("gtkglsink", "gtkglsink");


	/* Here we create sink element, which will provide us widget
	If it fails then use OpenGL version of video sink */
	if(videosink && gtkglsink)
	{
		g_print("Successfully created GTK GL sink\n");
		g_object_set(videosink, "sink", gtkglsink, NULL);

		g_object_get(gtkglsink, "widget", &data.sink_widget, NULL);	/* save widget, where we want to display our GUI*/	
	}
	else
	{
		g_print("Could not create gtkglsink,    Falling back of gtksink\n");
		videosink = gst_element_factory_make("gtksink", "gtksink");
		g_object_get(videosink, "widget", &data.sink_widget, NULL);   /* save widget, where we want to display our GUI*/
	}

	if(!data.playbin || !videosink)
	{
		g_printerr("All elements are not created\n");
		return -1;
	}

	g_object_set(data.playbin, "uri", "https://gstreamer.freedesktop.org/data/media/sintel_trailer-480p.webm", NULL);

	/*set video-sink*/
	g_object_set(data.playbin, "video-sink", videosink, NULL);
	
	/*connect to instresting signal in playbin */
	g_signal_connect(G_OBJECT(data.playbin), "video-tags-changed", (GCallback)tags_cb, &data);
	g_signal_connect(G_OBJECT(data.playbin), "audio-tags-changed", (GCallback)tags_cb, &data);
	g_signal_connect(G_OBJECT(data.playbin), "text-tags-changed", (GCallback)tags_cb, &data);

	/*create the GUI*/
	create_ui(&data);

	bus = gst_element_get_bus(data.playbin);
	gst_bus_add_signal_watch(bus);
	g_signal_connect(G_OBJECT(bus), "message::error", (GCallback)error_cb, &data);
	g_signal_connect(G_OBJECT(bus), "message::eos", (GCallback)eos_cb, &data);
	g_signal_connect(G_OBJECT(bus), "message::state-changed", (GCallback)state_changed_cb, &data);
	g_signal_connect(G_OBJECT(bus), "message::application", (GCallback)application_cb, &data); 
	gst_object_unref(bus);


	/*Start playing*/
	ret = gst_element_set_state(data.playbin, GST_STATE_PLAYING);
	if(ret == GST_STATE_CHANGE_FAILURE)
	{
		g_printerr("Unable to set the pipeline in playing state\n");
		gst_object_unref(data.playbin);
		gst_object_unref(videosink);
		return -1;
	}

	/*Register a funcation that Glib will call every second */
	g_timeout_add_seconds(1, (GSourceFunc)refresh_ui, &data);

	/* Start GTK main loop, we will not regain control until gtk_main is called */
	gtk_main();
	
	g_print("Quiting.... \n");
	/*Free resources */
	gst_element_set_state(data.playbin, GST_STATE_NULL);
	gst_object_unref(data.playbin);

	return 0;
}
